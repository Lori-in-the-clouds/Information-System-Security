\chapter{First lab}
\section{User Mode Emulation}

\begin{table}[htbp]
    \centering
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Function} & \textbf{Command in Listings} \\
        \hline
        \begin{lstlisting}[language=bash]
            arm-linux-gnueabi-gcc -o <filename.o> -static <filename.c>
            \end{lstlisting}
        {backgroundcolor=\color{gray!10}} \\
        \hline
        Font style & \texttt{basicstyle=\ttfamily\footnotesize} \\
        \hline
        Line breaks & \texttt{breaklines=true} \\
        \hline
        Column formatting & \texttt{columns=fullflexible} \\
        \hline
        Line numbers & \texttt{numbers=left} \\
        \hline
        Line number style & \texttt{numberstyle=\tiny\color{gray}} \\
        \hline
        Comment style & \texttt{commentstyle=\color{green}} \\
        \hline
        Keyword style & \texttt{keywordstyle=\color{blue}\bfseries} \\
        \hline
        String style & \texttt{stringstyle=\color{red}} \\
        \hline
        Inline comment style & \texttt{moredelim=**[is][\color{gray}]{//}{//}} \\
        \hline
        Frame around code & \texttt{frame=single} \\
        \hline
    \end{tabular}
    \caption{Listings Command Functionality Table}
\end{table}
\subsection*{2. Compile the Hello World Program for ARM}
Compile the program for ARM using the GNU ARM toolchain:
\begin{lstlisting}[language=bash]
arm-linux-gnueabi-gcc -o <filename.o> -static <filename.c>
\end{lstlisting}

\subsection*{3. Attempt to Run the ARM Executable on the Host Machine}
Run the ARM binary on the host machine:
\begin{lstlisting}[language=bash]
./helloarm.o
\end{lstlisting}
This will produce the following error:
\begin{quote}
\texttt{-bash: ./helloarm.o: cannot execute binary file: Exec format error}
\end{quote}

\subsection*{4. Verify the Architecture of the ARM Executable}
Verify the architecture of the ARM binary:
\begin{lstlisting}[language=bash]
file helloarm.o
\end{lstlisting}
The output should look like:
\begin{quote}
\texttt{helloarm.o: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, not stripped}
\end{quote}

\subsection*{5. Compile the Hello World Program for the Host Machine}
Compile the program for the host machine:
\begin{lstlisting}[language=bash]
gcc -o hellohost.o hello.c
\end{lstlisting}

\subsection*{6. Run the Program Compiled for the Host Machine}
Run the host machine binary:
\begin{lstlisting}[language=bash]
./hellohost.o
\end{lstlisting}
You should see:
\begin{quote}
\texttt{Hello, World!}
\end{quote}

\subsection*{7. Verify the Architecture of the Host Executable}
Verify the architecture of the host binary:
\begin{lstlisting}[language=bash]
file hellohost.o
\end{lstlisting}
The output will indicate the architecture, for example:
\begin{quote}
\texttt{hellohost.o: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, not stripped}
\end{quote}

\subsection*{8. Install QEMU for User Mode Emulation}
Install QEMU for user mode emulation:
\begin{lstlisting}[language=bash]
sudo apt install qemu-user
\end{lstlisting}

\subsection*{9. Run the ARM Program on QEMU in User Mode Emulation}
Run the ARM binary on your host machine using QEMU:
\begin{lstlisting}[language=bash]
qemu-arm helloarm.o
\end{lstlisting}
You should see:
\begin{quote}
\texttt{Hello, World!}
\end{quote}

\subsection{Conclusion}
This exercise demonstrates how to compile and run a program for a different architecture using QEMU's User Mode Emulation.

\section{Exercise 2: Bare Metal Simulation}
\section*{Package Installation}

\subsection*{Installing QEMU System Emulation}

To get started, install the QEMU System Emulation package by running the following command:

\begin{lstlisting}
sudo apt install qemu-system-arm
\end{lstlisting}

\subsection*{Installing the ARM Cross-Compiler}

After installing QEMU System Emulation, you need to install the ARM cross-compiler. For this exercise, we will use the \texttt{gcc-arm-none-eabi} package to compile code for a bare metal system. To install it, run the following command:

\begin{lstlisting}
sudo apt install gcc-arm-none-eabi
\end{lstlisting}

\section*{Create the Bare Metal Program}

We will create three files: \texttt{main.c}, \texttt{startup.s}, and \texttt{linker.ld}.

\subsection*{Create \texttt{main.c} File}

The \texttt{main.c} file contains a simple program to print "Hello world!" to the UART peripheral. The UART peripheral is memory-mapped to the address \texttt{0x40011004}. The program writes each character of the message to the UART peripheral until the end of the string is reached. The program then enters an infinite loop.

Here is the content of the \texttt{main.c} file:

\begin{lstlisting}[language=C]
volatile unsigned int *const USART1_PTR = (unsigned int *)0x40011004;

void my_printf(const char *s) {
    while(*s != '\0') {  /* Loop until end of string */
        *USART1_PTR = (unsigned int)(*s);  /* Transmit char */
        s++;  /* Next char */
    }
}

int main(void) {
    my_printf("Hello world!\n");
}
\end{lstlisting}

\subsection*{Create \texttt{startup.s} File}

The \texttt{startup.s} file defines the entry point of the program. This is a simple assembly file where the execution starts.

Here is the content of the \texttt{startup.s} file:

\begin{lstlisting}
.word stack_top    // Address of the stack_top
.word _start       // Address of the _start label

.thumb_func 
.global _start

_start:
    BL main
    B .
\end{lstlisting}

\subsection*{Create \texttt{linker.ld} File}

The \texttt{linker.ld} file defines the memory regions of the program, such as the text section (code), data section (initialized variables), bss section (uninitialized variables), and stack section.

Here is the content of the \texttt{linker.ld} file:

\begin{lstlisting}
ENTRY(_start)

SECTIONS
{
    .text : { *(.text*) }        
    .data : { *(.data) }
    .bss : { *(.bss*) }
    stack_top = 0x2001ffff; 
}
\end{lstlisting}

\section*{Compile the Bare Metal Program}

Now we need to compile the program.

\subsection*{Compile \texttt{startup.s} File}

Use the ARM assembler to compile the \texttt{startup.s} file into an object file:

\begin{lstlisting}
arm-none-eabi-as -mcpu=cortex-m4 startup.s -o startup.o
\end{lstlisting}

\subsection*{Compile \texttt{main.c} File}

Use the ARM GCC compiler to compile the \texttt{main.c} file:

\begin{lstlisting}
arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb main.c -o main.o
\end{lstlisting}

\subsection*{Link Object Files to Create \texttt{main.elf}}

Link the object files (\texttt{startup.o} and \texttt{main.o}) together using the ARM linker, along with the linker script:

\begin{lstlisting}
arm-none-eabi-ld -T linker.ld startup.o main.o -o main.elf
\end{lstlisting}

\section*{QEMU Simulation}

Now that we have the \texttt{main.elf} executable, we can run the program using QEMU. This simulates the bare metal ARM system on QEMU with the Netduino Plus 2 board.

To run the program on QEMU, use the following command:

\begin{lstlisting}
qemu-system-arm -M netduino2 -nographic -kernel main.elf
\end{lstlisting}

Hereâ€™s what each flag does:
\begin{itemize}
    \item \texttt{-M netduino2}: Specifies the machine type to simulate (in this case, the Netduino Plus 2 board).
    \item \texttt{-nographic}: Runs QEMU without a graphical interface (all output will be in the terminal).
    \item \texttt{-kernel main.elf}: Specifies the kernel (or in this case, the compiled bare metal program) to run.
\end{itemize}

\section*{Ending the Simulation}

To stop the simulation in QEMU, press:

\begin{lstlisting}
Ctrl + A, then X
\end{lstlisting}


hofatto questo per eseguire: arm-none-eabi-gcc -o delay.o -c delay.c



